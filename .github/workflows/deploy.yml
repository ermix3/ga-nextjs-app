name: Deploy NextJS Frontend

on:
  push:
    branches:
      - main

env:
  REGISTRY: docker.io
  IMAGE_NAME: nextjs-frontend
  SHORT_SHA: ${{ github.sha }}
  NETWORK_NAME: fullstack-network
  DEPLOYMENT_TIMEOUT: 120

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Set short SHA
        run: echo "SHORT_SHA=$(git rev-parse --short HEAD)" >> $GITHUB_ENV

      - name: Build and push
        uses: docker/build-push-action@v3
        with:
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ secrets.DOCKER_HUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest
            ${{ env.REGISTRY }}/${{ secrets.DOCKER_HUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ env.SHORT_SHA }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up SSH key
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          known_hosts: ${{ secrets.SSH_KNOWN_HOSTS }}

      - name: Copy files to server
        run: |
          scp -o StrictHostKeyChecking=no docker-compose.prod.yml root@${{ secrets.SERVER_IP }}:/frontend
          scp -o StrictHostKeyChecking=no nginx.frontend.conf root@${{ secrets.SERVER_IP }}:/frontend

      - name: Deploy with Zero Downtime
        env:
          FRONTEND_IMAGE: ${{ env.REGISTRY }}/${{ secrets.DOCKER_HUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest
        run: |
          ssh -o StrictHostKeyChecking=no root@${{ secrets.SERVER_IP }} << EOF
            cd /frontend
          
            export DOCKER_HUB_USERNAME=${{ secrets.DOCKER_HUB_USERNAME }}
            export IMAGE_NAME=${{ env.IMAGE_NAME }}
            export APP_NAME=${{ secrets.APP_NAME }}
            export DEPLOYMENT_TIMEOUT=${{ env.DEPLOYMENT_TIMEOUT }}
            export SHORT_SHA=${{ env.SHORT_SHA }}
          
            echo "Pulling latest frontend image..."
            docker pull \${FRONTEND_IMAGE}

            # Generate new container name with timestamp and short SHA
            TIMESTAMP=\$(date +%Y%m%d%H%M%S)
            NEW_CONTAINER_NAME=\${APP_NAME}_frontend_\${TIMESTAMP}_\${SHORT_SHA}

            # Start new container with health check
            echo "Starting new container..."
            if command -v docker compose &> /dev/null; then
              docker compose -f docker-compose.prod.yml run -d \
                --name \${NEW_CONTAINER_NAME} \
                --network \${NETWORK_NAME} \
                --health-cmd "curl -f http://localhost:3000 || exit 1" \
                --health-interval 5s \
                --health-retries 6 \
                --health-timeout 2s \
                --health-start-period 10s \
                frontend
            else
              docker-compose -f docker-compose.prod.yml run -d \
                --name \${NEW_CONTAINER_NAME} \
                --network \${NETWORK_NAME} \
                --health-cmd "curl -f http://localhost:3000 || exit 1" \
                --health-interval 5s \
                --health-retries 6 \
                --health-timeout 2s \
                --health-start-period 10s \
                frontend
            fi

            # Wait for new container to become healthy
            echo "Waiting for new container to become healthy..."
            START_TIME=\$(date +%s)
            while true; do
              CONTAINER_STATUS=\$(docker inspect --format '{{.State.Health.Status}}' \${NEW_CONTAINER_NAME})
              
              if [ "\$CONTAINER_STATUS" = "healthy" ]; then
                echo "New container is healthy!"
                break
              fi
              
              CURRENT_TIME=\$(date +%s)
              ELAPSED_TIME=\$((CURRENT_TIME - START_TIME))
              
              if [ \$ELAPSED_TIME -gt \$DEPLOYMENT_TIMEOUT ]; then
                echo "Timeout reached. New container did not become healthy."
                docker logs \${NEW_CONTAINER_NAME}
                docker rm -f \${NEW_CONTAINER_NAME}
                exit 1
              fi
              
              sleep 5
              echo "Waiting for container to become healthy... Current status: \$CONTAINER_STATUS"
            done

            # Update Nginx configuration (if needed)
            # docker exec \${APP_NAME}_nginx nginx -s reload

            # Stop and remove old container
            OLD_CONTAINER_ID=\$(docker ps -q -f name=\${APP_NAME}_frontend)
            if [ ! -z "\$OLD_CONTAINER_ID" ]; then
              echo "Stopping old container..."
              docker stop \$OLD_CONTAINER_ID
              docker rm \$OLD_CONTAINER_ID
            fi

            # Rename new container to standard name
            echo "Renaming new container to standard name..."
            docker rename \${NEW_CONTAINER_NAME} \${APP_NAME}_frontend

            # Clean up old containers
            echo "Cleaning up old containers..."
            docker ps -a -q -f name=\${APP_NAME}_frontend_ | grep -v \$(docker ps -q -f name=\${APP_NAME}_frontend) | xargs --no-run-if-empty docker rm -f

            echo "Deployment completed successfully with zero downtime!"
          EOF